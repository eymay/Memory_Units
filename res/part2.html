<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hw5 part2</title>
    <style>
        .c1 {
            color: rgb(0, 189, 0);
        }
        .c2 {
            color: rgb(221, 90, 90);
        }
        .c3 {
            color: rgb(218, 145, 9);
        }
        .c4 {
            color: rgb(99, 99, 228);
        }
        .c5 {
            color: rgb(196, 52, 196);
        }
        #t1 {
            font-family: 'Times New Roman', Times, serif;
            font-size: 15px;
            margin-bottom: 50px;
        }
        #t1 thead {
            border-bottom: 3px solid black;
            /* box-shadow: 3px 5px black; */
            /* blur */
        }
        #t1 thead td {
            /* text-align: center; */
            padding-left: 8px;
            font-weight: bold;

        }
        #t1 tbody td {
            box-shadow: 0px 0px 2px black;
            padding: 1px 10px;
        }
        

        

        .cod {
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
        }

        .t2 {
            max-width: 95%;
            box-shadow: 0px 0px 3px green;
            padding-top: 10px;
            padding-bottom: 10px;
            margin: 10px 10px 10px 0px;
        }

        .t2 > div {
            display: flex;
        }
        .t2 div {
            /* border: 1px solid red; */
            padding-top: 0px;
            padding-bottom: 0px;
        }

        .t2:nth-child(6){
            margin-top: 50px;
            margin-bottom: 20px;
            position: relative;
            top: 10px;
        }

        .t2:nth-child(13) {
            margin-top: 150px;
            margin-bottom: 20px;
            position: relative;
            top: 10px;
        }

        .t2para {
            color:rgb(143, 27, 27);
            padding: 10px;
        }
        .t2left {
            font-weight: bolder;
            text-align: center;
            flex: 1;
        }
        .t2left > div:nth-child(2){
            margin-top: -3px;
            margin-bottom: -3px;
            color: gray;
        }
        .t2digits > div:nth-child(2) {
            margin-top: -6px;
            margin-bottom: -6px;
            color: blue;
        }
        .t2digits > div:nth-child(3) {
            font-style: italic;
        }
        .t2digits > div:nth-child(1) {
            font-size: 18px;
        }
        .t2right {
            flex:3;
            display: flex;
        }
        .t2digits {
            flex: 1;
            text-align: center;
            margin-left: 5px;
            margin-right: 5px;
        }
        .t2right > :nth-child(1), .t2right > :nth-last-child(1) {
            flex: 10;
        }

        authors {
            position: relative;
            top: -10px;
        }

        h3.nop {
            margin-top: 60px;
        }
    </style>
</head>
<body>

    <h1>VLSI II - Assignment 5</h1>
    <authors>
    <p>Mehmet Eymen Ãœnay 040190218 <br>
    Deniz Bashgoren 040180902</p>
    </authors>

    <h3>RV32I Instruction Set</h3>
    <p>The table of all RV32I instructions and a short description in pseudocode:</p>

    <table id="t1">
        <thead>
            <td>Opcode</td>
            <td>Name</td>
            <td>Pseudocode</td>
        </thead>
        <tbody id="i1"></tbody>
    </table>

    <h3>Encoding of RV32I Instructions</h3>
    <p>16 of the RV32I instructions have been selected and their encoding is analyzed below.</p>

    <section id="t2section">
    <div class="t2">
        <div>
            <div class="t2left">
                <div> ADD x2, x4, x4: </div>
                <div> x2 ðŸ¡¨ðŸ¡¨ x4 + x4</div>
                <div> R-TYPE </div>
            </div>
            <div class="t2right">
                <div></div>
                <div class="t2digits">
                    <div>0000000</div>
                    <div>ðŸ¡«</div>
                    <div>func7</div>
                </div>
                <div class="t2digits">
                    <div>00100</div>
                    <div>ðŸ¡«</div>
                    <div>rs2</div>
                </div>
                <div class="t2digits">
                    <div>00010</div>
                    <div>ðŸ¡«</div>
                    <div>rs1</div>
                </div>
                <div class="t2digits">
                    <div>000</div>
                    <div>ðŸ¡«</div>
                    <div>func3</div>
                </div>
                <div class="t2digits">
                    <div>00100</div>
                    <div>ðŸ¡«</div>
                    <div>rd</div>
                </div>
                <div class="t2digits">
                    <div>0110011</div>
                    <div>ðŸ¡«</div>
                    <div>opcode</div>
                </div>
                <div></div>
            </div>
        </div>
        <div class="t2para">
            Add te values from asdff and fg gf  and then asdf sg sdf them.
        </div>
    </div>


    <div class="t2">
        <div>
            <div class="t2left">
                <div> ADD x2, x4, x4: </div>
                <div> x2 ðŸ¡¨ðŸ¡¨ x4 + x4</div>
                <div> R-TYPE </div>
            </div>
            <div class="t2right">
                <div></div>
                <div class="t2digits">
                    <div>0000000</div>
                    <div>ðŸ¡«</div>
                    <div>func7</div>
                </div>
                <div class="t2digits">
                    <div>00100</div>
                    <div>ðŸ¡«</div>
                    <div>rs2</div>
                </div>
                <div class="t2digits">
                    <div>00010</div>
                    <div>ðŸ¡«</div>
                    <div>rs1</div>
                </div>
                <div class="t2digits">
                    <div>000</div>
                    <div>ðŸ¡«</div>
                    <div>func3</div>
                </div>
                <div class="t2digits">
                    <div>00100</div>
                    <div>ðŸ¡«</div>
                    <div>rd</div>
                </div>
                <div class="t2digits">
                    <div>0110011</div>
                    <div>ðŸ¡«</div>
                    <div>opcode</div>
                </div>
                <div></div>
            </div>
        </div>
        <div class="t2para">
            Add te values from asdff and fg gf  and then asdf sg sdf them.
        </div>
    </div>


    <div class="t2">
        <div>
            <div class="t2left">
                <div> ADD x2, x4, x4: </div>
                <div> x2 ðŸ¡¨ðŸ¡¨ x4 + x4</div>
                <div> R-TYPE </div>
            </div>
            <div class="t2right">
                <div></div>
                <div class="t2digits">
                    <div>0000000</div>
                    <div>ðŸ¡«</div>
                    <div>func7</div>
                </div>
                <div class="t2digits">
                    <div>00100</div>
                    <div>ðŸ¡«</div>
                    <div>rs2</div>
                </div>
                <div class="t2digits">
                    <div>00010</div>
                    <div>ðŸ¡«</div>
                    <div>rs1</div>
                </div>
                <div class="t2digits">
                    <div>000</div>
                    <div>ðŸ¡«</div>
                    <div>func3</div>
                </div>
                <div class="t2digits">
                    <div>00100</div>
                    <div>ðŸ¡«</div>
                    <div>rd</div>
                </div>
                <div class="t2digits">
                    <div>0110011</div>
                    <div>ðŸ¡«</div>
                    <div>opcode</div>
                </div>
                <div></div>
            </div>
        </div>
        <div class="t2para">
            Add te values from asdff and fg gf  and then asdf sg sdf them.
            Add te values from asdff and fg gf  and then asdf sg sdf them.
            Add te values from asdff and fg gf  and then asdf sg sdf them.
        </div>
    </div>
    </section>
    
    <h3 class="nop">The NOP and HINT instructions</h3>
    <p>
        NOP is a pseudoinstruction that does nothing, but occupy space. This is desired in cases like:
        </p>
        <ul>
            <li>When we want to make sure there is enough space between certain instructions</li>
            <li>In jump tables (such as in switch statements in C), where the distance in instructions needs to be precise</li>
            <li>At the end of the program, to make sure that the program doesn&#39;t trigger a trap</li>
        </ul>
        <p>
        In practice, any instruction that doesn't change the state of the registers and the memory can be used as a NOP, however,
        the RISC-V specification defines a canonical encoding for the NOP: <code>addi x0, x0, 0</code> (in hexadecimal: 0x00000013).
    </p>
    <p>
        Other encodings of NOP have been named as HINT instructions in the standard. These have no effect on the visible state but may be used to communicate
        with the RISC-V hardware in an implementation-specific way. For example, a hardware implementer might define that <code>slti x0, x1, 2</code> can be used
        to signal the hardware that the next branch is not likely to be taken. This permits the ISA users to mark branches unlikely to be taken in this way, thereby
        allowing the hardware to optimize its internal circuitry. The table of all reserved and non-reserved hint instructions:
    </p>
    <img src="hint_instrs.png">

    <h3>Instruction Memory</h3>
    <p>
        In the testbench, we first load the instructions from the file <code>instInit.txt</code> into a register internal to the testbench, named <code>instructions</code>.
        The instInit file holds the instructions in hexadecimal format, however, if its binary equivalent is also provided as a seperate file <code>instInitBin.txt</code>.
        In the testbench we first demonstrate that rst works asynchronously. As seen in the waveform below, the contents of the memory change to 0 right when rst is activated.
    </p>
        <img src="instmem_isasync.png">
    <p>
        Next, we demonstrate that while we=0, the write operations won&#39;t work. First we try to fill up the memory while we0=0, and then while we0=1.
    </p>
    <!-- <img src="instmem_before.png">
    <img src="instmem_after.png"> -->

    


    <code>
    <pre>
Address:   0 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
Address:   1 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
Address:   2 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
Address:   3 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
Address:   4 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
Address:   5 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
Address:   6 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
Address:   7 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
...
</pre>
</code>

<code>
    <pre>
Address:   0 Data_Hex: 00011f37 Data_Bin: 00000000000000010001111100110111
Address:   1 Data_Hex: 00040697 Data_Bin: 00000000000001000000011010010111
Address:   2 Data_Hex: 45b0e0ef Data_Bin: 01000101101100001110000011101111
Address:   3 Data_Hex: 06054e63 Data_Bin: 00000110000001010100111001100011
Address:   4 Data_Hex: 4037da93 Data_Bin: 01000000001101111101101010010011
Address:   5 Data_Hex: 00f501a3 Data_Bin: 00000000111101010000000110100011
Address:   6 Data_Hex: 01050793 Data_Bin: 00000001000001010000011110010011
Address:   7 Data_Hex: 1b378863 Data_Bin: 00011011001101111000100001100011
...
</pre>
</code>

<p>Running the testbench repeatedly emits the warning: <code>VCD warning: array word InstMem_Tb.m.mem[0] will conflict with an escaped identifier.
</code>. It can be suppressed as explained in <code>https://stackoverflow.com/questions/20317820/</code>. We decided to keep the code simpler at the cost of this warning. </p>

<h3>Data Memory</h3>

<p><code>wr_strb</code> is encoded as following:</p>
<code>
<pre>
input wire [2:0] wr_strb;
// wr_strb = 000 -> store word
// wr_strb = 001 -> store lower halfword
// wr_strb = 010 -> nop
// wr_strb = 011 -> store higher halfword
// wr_strb = 100 -> store lowest byte
// wr_strb = 101 -> store 2nd lowest byte
// wr_strb = 110 -> store 3rd lowest byte
// wr_strb = 111 -> store highest byte
</pre>
</code>
<p>The state 010 is chosen to be nop to simplify the hardware: the msb bit controls the byte-level stores; the lsb bit controls the halfword-level stores and the combination 000 is for word-level stores.
The enum-like encoding of wr_strb allows us increment it in the testbench as if it was an integer. In the testbench, a value of 0xAABBCCDD is placed in the addresses starting from 0, but each time with a new wr_strb mode.
The values are stored in little endian order. In the testbench we&#39;ve redefined DEPTH=8 so that the console output is more consice, however it can easily be changed to its original value of 128. The end result is as following:</p>
<code>
<pre>
...
Address: 0 Data_Hex: aabbccdd Data_Bin: 10101010101110111100110011011101
Address: 1 Data_Hex: 0000ccdd Data_Bin: 00000000000000001100110011011101
Address: 2 Data_Hex: 00000000 Data_Bin: 00000000000000000000000000000000
Address: 3 Data_Hex: ccdd0000 Data_Bin: 11001100110111010000000000000000
Address: 4 Data_Hex: 000000dd Data_Bin: 00000000000000000000000011011101
Address: 5 Data_Hex: 0000dd00 Data_Bin: 00000000000000001101110100000000
Address: 6 Data_Hex: 00dd0000 Data_Bin: 00000000110111010000000000000000
Address: 7 Data_Hex: dd000000 Data_Bin: 11011101000000000000000000000000
</pre>
</code>







    <script>

        let a =[
        ["LUI    " , " Load upper immediate " , "               rd ðŸ¡¨ imm << 12" ],
        ["AUIPC  " , " Add upper immediate to PC " , "          rd ðŸ¡¨ pc + offset << 12" ],
        ["JAL    " , " Jump and link " ,                      ["rd ðŸ¡¨ pc + length(inst)"," pc ðŸ¡¨ pc + offset"] ],
        ["JALR   " , " Jump and link register " , ["             rd ðŸ¡¨ pc + length(inst)"," pc ðŸ¡¨ (rs1 + offset) âˆ§ -2"] ], 
        ["BEQ    " , " Branch equal " , "                       if rs1 = rs2 then pc ðŸ¡¨ pc + offset " ],
        ["BNE    " , " Branch not equal  " , "                  if rs1 â‰  rs2 then pc ðŸ¡¨ pc + offset " ],
        ["BLT    " , " Branch less than " , "                   if rs1 < rs2 then pc ðŸ¡¨ pc + offset " ],
        ["BGE    " , " Branch greater  " , "                    if rs1 â‰¥ rs2 then pc ðŸ¡¨ pc + offset " ],
        ["BLTU   " , " Branch less than unsigned " , "          if rs1 < rs2 then pc ðŸ¡¨ pc + offset " ],
        ["BGEU   " , " Branch greater than unsigned " , "       if rs1 â‰¥ rs2 then pc ðŸ¡¨ pc + offset " ],
        ["LB     " , " Load byte " , "                          rd ðŸ¡¨ s8[rs1 + offset] " ],
        ["LH     " , " Load halfword " , "                      rd ðŸ¡¨ s16[rs1 + offset] " ],
        ["LW     " , " Load word " , "                          rd ðŸ¡¨ s32[rs1 + offset] " ],
        ["LBU    " , " Load byte unsigned " , "                 rd ðŸ¡¨ u8[rs1 + offset] " ],
        ["LHU    " , " Load halfword unsigned " , "             rd ðŸ¡¨ u16[rs1 + offset] " ],
        ["SB     " , " Store byte " , "                         u8[rs1 + offset] ðŸ¡¨ rs2 " ],
        ["SH     " , " Store halfword " , "                     u16[rs1 + offset] ðŸ¡¨ rs2 " ],
        ["SW     " , " Store word " , "                         u32[rs1 + offset] ðŸ¡¨ rs2 " ],
        ["ADDI   " , " Add immediate " , "                      rd ðŸ¡¨ rs1 + sx(imm) " ],
        ["SLTI   " , " Set less than immediate " , "            rd ðŸ¡¨ sx(rs1) < sx(imm) " ],
        ["SLTIU  " , " Set less than immediate unsigned " , "   rd ðŸ¡¨ ux(rs1) < ux(imm) " ],
        ["XORI   " , " Exclusive or immediate " , "             rd ðŸ¡¨ ux(rs1) ^ ux(imm) " ],
        ["ORI    " , " Or immediate " , "                       rd ðŸ¡¨ ux(rs1) | ux(imm) " ],
        ["ANDI   " , " And immediate " , "                      rd ðŸ¡¨ ux(rs1) & ux(imm) " ],
        ["SLLI   " , " Shift left logic immediate " , "         rd ðŸ¡¨ ux(rs1) << ux(imm) " ],
        ["SRLI   " , " Shift right logic immediate " , "        rd ðŸ¡¨ ux(rs1) >> ux(imm) " ],
        ["SRAI   " , " Shift right arithmetic immediate " , "   rd ðŸ¡¨ sx(rs1) >> ux(imm) " ],
        ["ADD    " , " Add " , "                                rd ðŸ¡¨ sx(rs1) + sx(rs2) " ],
        ["SUB    " , " Subtract " , "                           rd ðŸ¡¨ sx(rs1) - sx(rs2) " ],
        ["SLL    " , " Shift left logical " , "                 rd ðŸ¡¨ ux(rs1) << rs2 " ],
        ["SLT    " , " Set less than " , "                      rd ðŸ¡¨ sx(rs1) < sx(rs2) " ],
        ["SLTU   " , " Set less than unsigned " , "             rd ðŸ¡¨ ux(rs1) < ux(rs2) " ],
        ["XOR    " , " Exclusive or " , "                       rd ðŸ¡¨ ux(rs1) ^ ux(rs2) " ],
        ["SRL    " , " Shift right logic " , "                  rd ðŸ¡¨ ux(rs1) >> rs2 " ],
        ["SRA    " , " Shift right arithmetic " , "             rd ðŸ¡¨ sx(rs1) >> rs2 " ],
        ["OR     " , " Or " , "                                 rd ðŸ¡¨ ux(rs1) | ux(rs2) " ],
        ["AND    " , " And " , "                                rd ðŸ¡¨ ux(rs1) & ux(rs2) " ]]

        function colorize(str) {
            return str.replaceAll('if', '<span class=c1>if</span>' ).
                replaceAll('then', '<span class=c1>then</span>' ).
                replaceAll('rs1', '<span class=c2>rs1</span>' ).
                replaceAll('rs2', '<span class=c2>rs2</span>' ).
                replaceAll('rd', '<span class=c2>rd</span>' ).
                replaceAll('pc', '<span class=c2>pc</span>' ).
                replaceAll('s8', '<span class=c3>s8</span>' ).
                replaceAll('s16', '<span class=c3>s16</span>' ).
                replaceAll('s32', '<span class=c3>s32</span>' ).
                replaceAll('u8', '<span class=c3>u8</span>' ).
                replaceAll('u16', '<span class=c3>u16</span>' ).
                replaceAll('u32', '<span class=c3>u32</span>' ).
                replaceAll('sx', '<span class=c4>sx</span>' ).
                replaceAll('ux', '<span class=c4>ux</span>' ).
                replaceAll('length', '<span class=c4>length</span>' ).
                replaceAll('imm', '<span class=c5>imm</span>' ).
                replaceAll('offset', '<span class=c5>offset</span>' ).
                replaceAll('inst', '<span class=c5>inst</span>' )
        }

        let str = ''
        a.forEach(a => {
            str += '<tr>'
            str += `<td>${a[0].trim()} </td>`
            str += `<td>${a[1].trim()}</td>`
            if (typeof a[2] == 'string') {
                str += `<td class=cod>${colorize(a[2]).trim()}</td>`
            }
            else {
                str += `<td class=cod>${colorize(a[2][0]).trim()}<br>`
                str += `${colorize(a[2][1]).trim()}</td>`
            }
            str += '</tr>'
        })

        document.getElementById('i1').innerHTML = str
        
        let entries = [
        // ['inst', 'desc', 'type', 'parag', [[123,'sd'],[342,'dsf']]],
        ['lui x30, 17', 'x30 ðŸ¡¨ 17 << 12','U-TYPE','Fill x30\'s upper 20 bits with 17.',[['imm[11:0]','00000000000000010001'], ['rd','11110'] ,['op','0110111']]],
        ['auipc x13, 64', 'x13 ðŸ¡¨ pc + 64 << 12','U-TYPE', 'Fill x13 with pc+64<<12.',[['imm[11:0]','00000000000001000000'] ,['rd','01101'] ,['op','0010111']]],
        ['jal x1, 60506', 'x1 ðŸ¡¨ pc + 32 <br> pc ðŸ¡¨ pc + 60506','J-TYPE', 'Save address of next instruction to x1, and jump 60506 addresses ahead.',[['imm[20]','0'], ['imm[10:1]','1000101101'], ['imm[11]','1'], ['imm[19:12]','00001110'] ,['rd','00001'] ,['op','1101111']]],
        ['blt x10, x0, 62', 'if x10 < x0 then <br> pc ðŸ¡¨ pc + 62','B-TYPE','If the value in x10 is less than the value in x0, jump 62 addresses ahead.',[['imm[12|10:5]','0000011'], ['rs2','00000'], ['rs1','01010'], ['fn','100'], ['imm[4:1|11]','11100'] ,['op','1100011']]],
        ['srai x21, x15, 3','x21 ðŸ¡¨ sx(x15) >> 3', 'I-TYPE','Shift bits stored in x15 3 bits to the right, while filling 3 new empty bits with the leftmost bit\'s value, and put it inside x21.',[['fn2','0100000' ],['shamt','00011'], ['rs1','01111'], ['fn1','101'] ,['rd','10101'] ,['op','0010011']]],
        ['sb x15, 3(x10)', 'u8[x10 + 3] ðŸ¡¨ x15','S-TYPE','Take the lowest byte from x15\'s value, and store it in the address x10+3.',[['imm[11:5]','0000000'] ,['rs2','01111'] ,['rs1','01010'], ['fn','000'],['imm[4:0]','00011'] ,['op','0100011']]],
        ['addi x15, x10, 16', 'x15 ðŸ¡¨ x10 + 16', 'I-TYPE', 'Add x10 with 16, put in x15.',[['imm[11:0]','000000010000'], ['rs1','01010'], ['fn','000'] ,['rd','01111'] ,['op','0010011']]],
        ['beq x15, x19, 432', 'if x15 = x19 then <br> pc ðŸ¡¨ pc + 432','B-TYPE','If the values in x15 and x19 are equal, jump 432 addresses ahead.',[['imm[12|10:5]','0001101'], ['rs2','10011'], ['rs1','01111'], ['fn','000'], ['imm[4:1|11]','10000'] ,['op','1100011']]],
        ['xori x9, x9, -1', 'x9 ðŸ¡¨ ux(x9) ^ -1', 'I-TYPE','Perform an xor operation bit-by-bit of the value in x9 and -1 (all 1s), then put back in x9.',[['imm[11:0]','111111111111'], ['rs1','01001'], ['fn','100'] ,['rd','01001'] ,['op','0010011']]],
        ['and x15, x25, x9', 'x15 ðŸ¡¨ ux(x25) & ux(x9)','R-TYPE', 'Perform a bitwise and operation on x25 and x9 then store the result in x15.',[['fn2','0000000'], ['rs2','01001'], ['rs1','11001'] ,['fn1','111'] ,['rd','01111'],['op','0110011']]],
        ['or x14, x10, x12', 'x14 ðŸ¡¨ ux(x10) | ux(x12)','R-TYPE', 'Perform a bitwise or operation on x10 and x12 then store the result in x14.', [['fn2','0000000'], ['rs2','01100'], ['rs1','01010'], ['fn1','110'] ,['rd','01110'],['op','0110011']]],
        ['lbu x28, 1(x10)', 'x28 ðŸ¡¨ u8[x10 + 1]','I-TYPE', 'Get the 8-bit value in the memory at the atddress x10+1, then put it on the lowest byte of x28, while filling the upper 3 bytes with zeros.',[['imm[11:0]','000000000001'], ['rs1','01010'], ['fn','100'] ,['rd','11100'] ,['op','0000011']]],
        ['slli x15, x14, 5', 'x15 ðŸ¡¨ ux(x14) << 5', 'I-TYPE','Shift bits stored in x14 5 bits to the left, while filling the 5 new empty bits with zeros (hence \'logic\' shift, and put it inside x15.',[['fn2','0000000'], ['shamt','00101'], ['rs1','01110'], ['fn1','001'] ,['rd','01111'] ,['op','0010011']]],
        ['sw x16, 4(x25)', 'u32[x25 + 4] ðŸ¡¨ x16','S-TYPE','Take the low 4 bytes from x16\'s value, put them in the 4 addresses starting from x25+4. The endianness is set by EEI during the execution, so it\'s not guaranteed, but in either case, loading the same bytes using LW instruction should give bytes in the same order.',[['imm[11:5]','0000000'], ['rs2','10000'], ['rs1','11001'], ['fn','010'] ,['imm[4:0]','00100'] ,['op','0100011']]],
        ['sub x15, x14, x8', 'x15 ðŸ¡¨ sx(x14) - sx(x8)','R-TYPE', 'Calculate the value x14-x8 by treating both registers as signed, and store the result in x15.',[['fn2','0100000'], ['rs2','01000'], ['rs1','01110'], ['fn1','000'] ,['rd','01111'] ,['op','0110011']]],
        ['bne x15, x14, -26', 'if x15 â‰  x14 then <br> pc ðŸ¡¨ pc - 26','B-TYPE','If the values in registers x15 and x14 are different, move 26 addresses backwards.',[['imm[12|10:5]','1111111'], ['rs2','01110'], ['rs1','01111'], ['fn','001'], ['imm[4:1|11]','00111'] ,['op','1100011']]],
        ] // inst, instdesc, type, parag, [digs, desc]
        str = ''
        entries.forEach(e => {
            let cs = ''
            // e[0] e[1] e[2] e[3] av cs
            e[4].forEach(d => {
                cs += `<div class="t2digits">
                    <div>${d[1]}</div>
                    <div>ðŸ¡«</div>
                    <div>${d[0]}</div>
                </div>`
            })

            str += `<div class="t2">
            <div>
                <div class="t2left">
                    <div> ${e[0]}</div>
                    <div> ${e[1]}</div>
                    <div> ${e[2]} </div>
                </div>
                <div class="t2right">
                    <div></div>
                    ${cs}<div></div>
                </div>
            </div>
            <div class="t2para">
               ${e[3]}</div>
            </div>`
        })

        document.getElementById('t2section').innerHTML = str


    </script>
</body>
</html>

